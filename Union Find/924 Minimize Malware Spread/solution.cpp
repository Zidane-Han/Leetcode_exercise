class Solution {
private:
    void makeRoot(vector<int>& root, int length) {
        root.resize(length);
        for (int i = 0; i < length; i++) {
            root[i] = i;
        }
    }
    
    int getRoot(int i) {
        while (i != root[i]) {
            root[i] = root[root[i]];
            i = root[i];
        }
        return i;
    }
    
    void connect(int p, int q) {
        int pid = getRoot(p);
        int qid = getRoot(q);
        root[pid] = qid;
    }
    
public:
    vector<int> root;
    
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int nnode = graph.size();
        makeRoot(root, nnode);
        
        for (int i = 0; i < nnode; i++) {
            for (int j = i + 1; j < nnode; j++) {
                if (graph[i][j] == 1)   connect(i, j);
            }
        }
        
        // dict {root_id : number of nodes}
        unordered_map<int, int> rootmemb;
        for (int i = 0; i < nnode; i++) {
            rootmemb[getRoot(i)]++;
        }
        
        sort(initial.begin(), initial.end());
        vector<int> initroot(initial.size());
        vector<int> freq(initial.size());
        for (int k = 0; k < initial.size(); k++) {
            int tmp = getRoot(initial[k]);
            initroot[k] = tmp;
            freq[k] = rootmemb[tmp];
        }
        
        // select appear once with largest freq
        int res = initial.front();
        int maxfreq = 0;
        for (int k = 0; k < initial.size(); k++) {
            if (count(initroot.begin(), initroot.end(), initroot[k]) == 1 && freq[k] > maxfreq) {
                res = initial[k];
                maxfreq = freq[k];
            }
        }
        return res;
    }
};
